from abc import ABC, abstractmethod
from typing import Tuple, List
from ..SettingsRetrievable import SettingsRetrievable
from ..Workspace import Workspace
from ..Random import Random
from ..Chain import Chain
from Bio.PDB.Atom import Atom
import pandas as pd





class Algorithm(SettingsRetrievable, ABC):

  def setup(self,
            targetPdb: str,
            workspaceDir: str
            ) -> Tuple[List[Atom], pd.DataFrame]:
    """
    Initializes the workspace and the RNG, as well as the reference backbone
    and the population before running the evolutionary algorithm.

    Parameters
    ----------
    targetPdb : str
        The path to the PDB file containing the target protein backbone.
    workspaceDir : str
        The folder where all the output files generated by the evolutionary
        algorithm will be stored.
    
    Returns
    -------
    Tuple[List[Bio.PDB.Atom.Atom], pandas.DataFrame]
        The reference backbone and the population from which the algorithm
        will begin its execution.
    """
    # initialize the workspace
    self.workspace = Workspace(workspaceDir, targetPdb)

    # initialize the RNG
    rng = Random.generator()
    initial = self.workspace.load_rng_state(loadCheckpoint=False)
    checkpoint = self.workspace.load_rng_state()
    state = checkpoint if checkpoint else initial
    if state:
      rng.bit_generator.state = state
    else:
      self.workspace.save_rng_state(rng.bit_generator.state, checkpoint=False)
    self.workspace.save_settings(self.settings())

    # load the target protein
    reference = Chain.load_structure(targetPdb)
    reference = Chain.backbone_atoms(reference)

    # check if we are restoring from a previous population
    population = self.workspace.load_population()
    return reference, population

  

  @abstractmethod
  def __call__(self, 
               reference: List[Atom], 
               population: pd.DataFrame,
               **kwargs
               ) -> None:
    raise NotImplementedError
